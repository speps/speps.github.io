<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on speps.fr - Rémi Gillig</title>
    <link>http://speps.fr/articles/</link>
    <description>Recent content in Articles on speps.fr - Rémi Gillig</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Jul 2020 19:46:57 +0000</lastBuildDate>
    <atom:link href="http://speps.fr/articles/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Torus Trooper - Rebooting a 15 year-old game written in D - Part 1 Compiling</title>
      <link>http://speps.fr/articles/torus-trooper-part1/</link>
      <pubDate>Sun, 12 Jul 2020 19:46:57 +0000</pubDate>
      
      <guid>http://speps.fr/articles/torus-trooper-part1/</guid>
      <description>

&lt;p&gt;While exploring D recently, I remembered a game I played while at university 15 years ago. For a long time, I couldn&amp;rsquo;t remember the name at all, only that it was from a Japanese developer. After some search wrangling, I finally managed to find the name of the game: Torus Trooper!&lt;/p&gt;

&lt;p&gt;You can find it there: &lt;a href=&#34;http://www.asahi-net.or.jp/~cs8k-cyu/windows/tt_e.html&#34;&gt;http://www.asahi-net.or.jp/~cs8k-cyu/windows/tt_e.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://speps.fr/media/articles/tt1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here is a copy of the tt0_22.zip file archived: &lt;a href=&#34;https://github.com/speps/tt/archive/legacy.zip&#34;&gt;https://github.com/speps/tt/archive/legacy.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What made me remember this game is that :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It came with &lt;a href=&#34;https://github.com/speps/tt/tree/legacy/src&#34;&gt;source code&lt;/a&gt;, quite unusual at the time for me&lt;/li&gt;
&lt;li&gt;Written in D, a language I didn&amp;rsquo;t know at all while I was busy studying C++&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s awfully addictive!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What better project than try to compile a D v0.110 project in a modern version of D! So here we are&amp;hellip;&lt;/p&gt;

&lt;p&gt;Part 1 - Compiling a new executable
Part 2 - Running the game for the first time
Part 3 - Making it cross platform&lt;/p&gt;

&lt;h2 id=&#34;switching-from-ant-to-dub:95834070c7040d18a199c0907f30b458&#34;&gt;Switching from Ant to DUB&lt;/h2&gt;

&lt;p&gt;The game used Ant and its &lt;code&gt;build.xml&lt;/code&gt; file to generate the executable, resources, etc. Since then, D added DUB as a build system / package manager so let&amp;rsquo;s use that!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;authors&amp;quot;: [
		&amp;quot;Kenta Cho&amp;quot;,
		&amp;quot;Remi Gillig&amp;quot;
	],
	&amp;quot;copyright&amp;quot;: &amp;quot;Copyright © 2004 - Kenta Cho, 2020 - Remi Gillig&amp;quot;,
	&amp;quot;description&amp;quot;: &amp;quot;Torus Trooper (Reboot)&amp;quot;,
	&amp;quot;license&amp;quot;: &amp;quot;BSD 2-clause&amp;quot;,
	&amp;quot;name&amp;quot;: &amp;quot;tt&amp;quot;,
	&amp;quot;targetType&amp;quot;: &amp;quot;executable&amp;quot;,
	&amp;quot;sourcePaths&amp;quot;: [
		&amp;quot;src&amp;quot;
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this initial &lt;code&gt;dub.json&lt;/code&gt; file, I was set to run the &lt;code&gt;dub&lt;/code&gt; command&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Performing &amp;quot;debug&amp;quot; build using C:\D\dmd2\windows\bin64\dmd.exe for x86.
tt ~master: building configuration &amp;quot;application&amp;quot;...
src\abagames\tt\barrage.d(95,33): Error: instead of C-style syntax, use D-style BulletMLParserTinyXML*[char[]][char[]] parser
src\abagames\tt\barrage.d(122,28): Error: instead of C-style syntax, use D-style BulletMLParserTinyXML*[] pl
src\abagames\tt\barrage.d(130,14): Error: instead of C-style syntax, use D-style BulletMLParserTinyXML*[char[]] pa
src\abagames\tt\boot.d(51,12): Error: instead of C-style syntax, use D-style char[4096] exe
src\abagames\tt\tunnel.d(300,14): Error: template argument expected following !
src\abagames\tt\tunnel.d(322,14): Error: template argument expected following !
src\abagames\util\rand.d(115,6): Error: instead of C-style syntax, use D-style uint[N] state
src\abagames\util\rand.d(140,20): Error: instead of C-style syntax, use D-style uint[] init_key
src\abagames\util\sdl\luminous.d(21,10): Error: instead of C-style syntax, use D-style GLuint[LUMINOUS_TEXTURE_WIDTH_MAX * LUMINOUS_TEXTURE_HEIGHT_MAX * 4 * (uint).sizeof] td
src\abagames\util\sdl\luminous.d(83,17): Error: instead of C-style syntax, use D-style float[2][2] lmOfs
C:\D\dmd2\windows\bin64\dmd.exe failed with exit code 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright let&amp;rsquo;s start and get this to compile!&lt;/p&gt;

&lt;h2 id=&#34;compiling:95834070c7040d18a199c0907f30b458&#34;&gt;Compiling&lt;/h2&gt;

&lt;h2 id=&#34;c-style-syntax-errors:95834070c7040d18a199c0907f30b458&#34;&gt;C-style syntax errors&lt;/h2&gt;

&lt;p&gt;This is one is easy to fix, the suggestion from the compiler works, I just replaced every instance of this error with the suggestion.&lt;/p&gt;

&lt;p&gt;Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/import/SDL_audio.d
+++ b/import/SDL_audio.d
@@ -42,7 +43,7 @@ struct SDL_AudioSpec {
     Once the callback returns, the buffer will no longer be valid.
     Stereo samples are stored in a LRLRLR ordering.
  */
- void (*callback)(void *userdata, Uint8 *stream, int len);
+ void function(void *userdata, Uint8 *stream, int len) callback;
  void  *userdata;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;error-template-argument-expected-following:95834070c7040d18a199c0907f30b458&#34;&gt;Error: template argument expected following !&lt;/h2&gt;

&lt;p&gt;This is an interesting one, here is one of the files where this error triggers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;  private void calcIndex(in float z, out int idx, out float ofs) {
    idx = slice.length + 99999;
    for (int i = 1; i &amp;lt; slice.length; i++) {
      if (z &amp;lt; slice[i].depth) {
        idx = i - 1;
        ofs = (z - slice[idx].depth) / (slice[idx + 1].depth - slice[idx].depth);
        break;
      }
    }
    if (idx &amp;lt; 0) {
      idx = 0;
      ofs = 0;
    } else if (idx &amp;gt;= slice.length - 1) {
      idx = slice.length - 2;
      ofs = 0.99;
    }
    if (ofs !&amp;gt;= 0) // ERROR HERE
      ofs = 0;
    else if (ofs &amp;gt;= 1)
      ofs = 0.99;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I did try a few searches without success so I asked on the D community forums and a few people guessed right, it&amp;rsquo;s of course a &lt;code&gt;not &amp;gt;=&lt;/code&gt;, equivalent to &lt;code&gt;&amp;lt;&lt;/code&gt;. However, &lt;a href=&#34;https://forum.dlang.org/post/rec3d1$toc$1@digitalmars.com&#34;&gt;thanks to Walter Bright&lt;/a&gt;, I got a link to the &lt;a href=&#34;https://www.digitalmars.com/ctg/ctgNumerics.html#comparisons&#34;&gt;original documentation from Digital Mars&lt;/a&gt;. The subtle difference with &lt;code&gt;!&amp;gt;=&lt;/code&gt; is that it will also return &lt;code&gt;true&lt;/code&gt; if any operands are &lt;code&gt;NaN&lt;/code&gt;. Suggested fix seems to have worked:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;    if (std.math.isNaN(ofs) || ofs &amp;lt; 0)
      ofs = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;replacing-char-with-string:95834070c7040d18a199c0907f30b458&#34;&gt;Replacing &lt;code&gt;char[]&lt;/code&gt; with &lt;code&gt;string&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;D1 used to have &lt;code&gt;char[]&lt;/code&gt; as the string type, and functions in &lt;code&gt;std.string&lt;/code&gt; in Phobos to manipulate this type. D2 added a dedidcated &lt;code&gt;string&lt;/code&gt; type instead of an alias. As a result, a lot of the code needs updating to deal with this. That includes the code in the custom bindings.&lt;/p&gt;

&lt;p&gt;Most of the changes here are similar to this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/barrage.d
+++ b/src/abagames/tt/barrage.d
@@ -92,24 +91,24 @@ public class Barrage {
  */
 public class BarrageManager {
  private:
-  static BulletMLParserTinyXML *parser[char[]][char[]];
-  static const char[] BARRAGE_DIR_NAME = &amp;quot;barrage&amp;quot;;
+  static BulletMLParserTinyXML*[string][string] parser;
+  static const string BARRAGE_DIR_NAME = &amp;quot;barrage&amp;quot;;
 
   public static void load() {
-    char[][] dirs = listdir(BARRAGE_DIR_NAME);
-    foreach (char[] dirName; dirs) {
-      char[][] files = listdir(BARRAGE_DIR_NAME ~ &amp;quot;/&amp;quot; ~ dirName);
-      foreach (char[] fileName; files) {
-        if (getExt(fileName) != &amp;quot;xml&amp;quot;)
+    string[] dirs = listdir(BARRAGE_DIR_NAME);
+    foreach (string dirName; dirs) {
+      string[] files = listdir(BARRAGE_DIR_NAME ~ &amp;quot;/&amp;quot; ~ dirName);
+      foreach (string fileName; files) {
+        if (fileName.extension != &amp;quot;.xml&amp;quot;)
           continue;
         parser[dirName][fileName] = getInstance(dirName, fileName);
       }
     }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;converting-value-to-string:95834070c7040d18a199c0907f30b458&#34;&gt;Converting value to string&lt;/h2&gt;

&lt;p&gt;D1 used to have &lt;code&gt;std.string.toString&lt;/code&gt; to convert a value to a &lt;code&gt;char[]&lt;/code&gt; value. This functionality was replaced by &lt;code&gt;std.conv.to!string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/shot.d
+++ b/src/abagames/tt/shot.d
@@ -5,6 +5,7 @@
  */
 module abagames.tt.shot;
 
+private import std.conv;
 private import std.math;
 private import std.string;
 private import opengl;
@@ -179,7 +180,7 @@ public class Shot: Actor {
       else if (sc &amp;gt;= 2000)
         size = 0.7;
       size *= (1 + multiplier * 0.01f);
-      fl.set(&amp;quot;X&amp;quot; ~ std.string.toString(multiplier), pos, size * pos.y,
+      fl.set(&amp;quot;X&amp;quot; ~ to!string(multiplier), pos, size * pos.y,
              cast(int) (30 + multiplier * 0.3f));
     }
     if (chargeShot) {
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;passing-strings-to-c:95834070c7040d18a199c0907f30b458&#34;&gt;Passing strings to C&lt;/h2&gt;

&lt;p&gt;The usual way to achieve seems to have been to just to use &lt;code&gt;std.string.toStringz&lt;/code&gt;. However, back in D1 it used to return char* :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char* toStringz(char[] s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This worked well for the C bindings but with D2, it now returns:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;immutable(char)* toStringz(scope return string s) pure nothrow @trusted;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, the fix is quite straightforward. For example, the bindings weren&amp;rsquo;t written with this in mind so they need fixing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/import/SDL_rwops.d
+++ b/import/SDL_rwops.d
@@ -81,7 +81,7 @@ struct SDL_RWops {
 
 /* Functions to create SDL_RWops structures from various data sources */
 
-SDL_RWops * SDL_RWFromFile(char *file, char *mode);
+SDL_RWops * SDL_RWFromFile(const char *file, const char *mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;simple-substitution:95834070c7040d18a199c0907f30b458&#34;&gt;Simple substitution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typedef&lt;/code&gt; → &lt;code&gt;alias&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/import/SDL_rwops.d
+++ b/import/SDL_rwops.d
@@ -28,10 +28,10 @@ import SDL_types;
 
 extern(C):
 
-typedef int (*_seek_func_t)(SDL_RWops *context, int offset, int whence);
-typedef int (*_read_func_t)(SDL_RWops *context, void *ptr, int size, int maxnum);
-typedef int (*_write_func_t)(SDL_RWops *context, void *ptr, int size, int num);
-typedef int (*_close_func_t)(SDL_RWops *context);
+alias int function(SDL_RWops *context, int offset, int whence) _seek_func_t;
+alias int function(SDL_RWops *context, void *ptr, int size, int maxnum) _read_func_t;
+alias int function(SDL_RWops *context, void *ptr, int size, int num) _write_func_t;
+alias int function(SDL_RWops *context) _close_func_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inout&lt;/code&gt; → &lt;code&gt;ref&lt;/code&gt;: this made sense for all instances where &lt;code&gt;inout&lt;/code&gt; was used&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/prefmanager.d
+++ b/src/abagames/tt/prefmanager.d
@@ -59,7 +59,7 @@ public class PrefData {
 
   public this() {
     gradeData = new GradeData[Ship.GRADE_NUM];
-    foreach (inout GradeData gd; gradeData)
+    foreach (ref GradeData gd; gradeData)
       gd = new GradeData;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto T&lt;/code&gt; → &lt;code&gt;auto&lt;/code&gt;: it seems the original author specified auto along with the type which isn&amp;rsquo;t allowed anymore&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/shape.d
+++ b/src/abagames/tt/shape.d
@@ -631,9 +631,9 @@ public class BulletShape: Drawable {
   }
 
   private void createSquareShape(bool wireShape) {
-    auto Vector3 cp = new Vector3;
-    auto Vector3[] p = new Vector3[4];
-    auto Vector3[] np = new Vector3[4];
+    auto cp = new Vector3;
+    auto p = new Vector3[4];
+    auto np = new Vector3[4];
     static const float[][][] POINT_DAT = [
       [[-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1], ],
       [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], ],
@@ -642,9 +642,9 @@ public class BulletShape: Drawable {
       [[1, -1, -1], [1, -1, 1], [1, 1, 1], [1, 1, -1], ],
       [[-1, -1, -1], [-1, -1, 1], [-1, 1, 1], [-1, 1, -1], ],
     ];
-    foreach (inout Vector3 ip; p)
+    foreach (ref Vector3 ip; p)
       ip = new Vector3;
-    foreach (inout Vector3 inp; np)
+    foreach (ref Vector3 inp; np)
       inp = new Vector3;
     for (int i = 0; i &amp;lt; 6; i++) {
       cp.x = cp.y = cp.z = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getExt&lt;/code&gt; → &lt;code&gt;.extension&lt;/code&gt;: behaviour is different but it&amp;rsquo;s easy enough to fix, it now includes the dot&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/soundmanager.d
+++ b/src/abagames/tt/soundmanager.d
@@ -44,10 +45,10 @@ public class SoundManager: abagames.util.sdl.sound.SoundManager {
 
   private static Music[] loadMusics() {
     Music[] musics;
-    char[][] files = listdir(Music.dir);
-    foreach (char[] fileName; files) {
-      char[] ext = getExt(fileName);
-      if (ext != &amp;quot;ogg&amp;quot; &amp;amp;&amp;amp; ext != &amp;quot;wav&amp;quot;)
+    string[] files = listdir(Music.dir);
+    foreach (string fileName; files) {
+      string ext = fileName.extension;
+      if (ext != &amp;quot;.ogg&amp;quot; &amp;amp;&amp;amp; ext != &amp;quot;.wav&amp;quot;)
         continue;
       Music music = new Music();
       music.load(fileName);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;catch(Object)&lt;/code&gt; → &lt;code&gt;catch(Throwable)&lt;/code&gt;: you could throw any &lt;code&gt;Object&lt;/code&gt; before, you have to use Throwable now&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/boot.d
+++ b/src/abagames/tt/boot.d
@@ -83,20 +84,20 @@ public int boot(char[][] args) {
   }
   try {
     mainLoop.loop();
-  } catch (Object o) {
+  } catch (Throwable t) {
     try {
       gameManager.saveErrorReplay();
-    } catch (Object o1) {}
-    throw o;
+    } catch (Throwable) {}
+    throw t;
   }
   return EXIT_SUCCESS;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bit&lt;/code&gt; → &lt;code&gt;SDL_bool&lt;/code&gt;: the bit was used back in D1, it behaved like a &lt;code&gt;bool&lt;/code&gt; but used one bit instead so you could make bitfields easily, it was mostly used in the SDL bindings so I replaced it with &lt;code&gt;SDL_bool&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/import/SDL_video.d
+++ b/import/SDL_video.d
@@ -132,7 +133,7 @@ const uint SDL_SRCALPHA	= 0x00010000;	/* Blit uses source alpha blending */
 const uint SDL_PREALLOC	= 0x01000000;	/* Surface uses preallocated memory */
 
 /* Evaluates to true if the surface needs to be locked before access */
-bit SDL_MUSTLOCK(SDL_Surface *surface)
+SDL_bool SDL_MUSTLOCK(SDL_Surface *surface)
 {
 	return surface.offset || ((surface.flags &amp;amp;
 		(SDL_HWSURFACE | SDL_ASYNCBLIT | SDL_RLEACCEL)) != 0);
@@ -184,13 +185,7 @@ struct SDL_Overlay {
 	void /*private_yuvhwdata*/ *hwdata;
 
 	/* Special flags */
-	union
-	{
-		bit hw_overlay;
-		Uint32 _dummy;
-	}
-//		Uint32 hw_overlay :1;	/* Flag: This overlay hardware accelerated? */
-//		Uint32 UnusedBits :31;
+	Uint32 flags;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;phobos:95834070c7040d18a199c0907f30b458&#34;&gt;Phobos&lt;/h2&gt;

&lt;p&gt;The old code did use &lt;code&gt;std.stream&lt;/code&gt;, from what I read this was deprecated in favor of splitting it into a more modular design. However, to transition old code someone rescued the deprecated code and made it into a DUB package called &lt;a href=&#34;https://code.dlang.org/packages/undead&#34;&gt;&lt;code&gt;undead&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This was very useful at the start to get the code to compile. However, I wanted to get rid of this dependency as it didn&amp;rsquo;t feel right to keep old code instead of relying on the modern D equivalent. In D1, &lt;code&gt;std.stream.File.read&lt;/code&gt; could read binary data into values. I&amp;rsquo;ve changed it to use &lt;code&gt;std.file.read&lt;/code&gt; and &lt;code&gt;std.bitmanip.read&lt;/code&gt;. It&amp;rsquo;s also important to make sure you specify the endian, the D1 code was implementation-specific regarding the format of types other than byte sized ones so I followed what convention it was on Windows which is little-endian. That means replays and highscores saves should be compatible!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/src/abagames/tt/replay.d
+++ b/src/abagames/tt/replay.d
@@ -5,7 +5,10 @@
  */
 module abagames.tt.replay;
 
-private import undead.stream;
+import std.file;
+import std.array;
+import std.bitmanip;
+
 private import abagames.util.sdl.recordablepad;
 
 /**
@@ -22,28 +25,24 @@ public class ReplayData {
  private:
 
   public void save(string fileName) {
-    auto fd = new File;
-    fd.create(dir ~ &amp;quot;/&amp;quot; ~ fileName);
-    fd.write(VERSION_NUM);
-    fd.write(level);
-    fd.write(grade);
-    fd.write(seed);
-    padRecord.save(fd);
-    fd.close();
+    auto buffer = appender!(ubyte[]);
+    buffer.append!(int, Endian.littleEndian)(VERSION_NUM);
+    buffer.append!(float, Endian.littleEndian)(level);
+    buffer.append!(int, Endian.littleEndian)(grade);
+    buffer.append!(long, Endian.littleEndian)(seed);
+    padRecord.save(buffer);
+    std.file.write(dir ~ &amp;quot;/&amp;quot; ~ fileName, buffer[]);
   }
 
   public void load(string fileName) {
-    auto fd = new File;
-    fd.open(dir ~ &amp;quot;/&amp;quot; ~ fileName);
-    int ver;
-    fd.read(ver);
+    auto buffer = cast(ubyte[])std.file.read(dir ~ &amp;quot;/&amp;quot; ~ fileName);
+    int ver = buffer.read!(int, Endian.littleEndian);
     if (ver != VERSION_NUM)
       throw new Error(&amp;quot;Wrong version num&amp;quot;);
-    fd.read(level);
-    fd.read(grade);
-    fd.read(seed);
+    level = buffer.read!(float, Endian.littleEndian);
+    grade = buffer.read!(int, Endian.littleEndian);
+    seed = buffer.read!(long, Endian.littleEndian);
     padRecord = new PadRecord;
-    padRecord.load(fd);
-    fd.close();
+    padRecord.load(buffer);
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;operator-overloading:95834070c7040d18a199c0907f30b458&#34;&gt;Operator overloading&lt;/h2&gt;

&lt;p&gt;There is a &lt;code&gt;Vector&lt;/code&gt; type in the codebase and naturally it used operator overloading. The syntax for this has changed though.&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;  public void opAddAssign(Vector v) {
    x += v.x;
    y += v.y;
  }

  public void opSubAssign(Vector v) {
    x -= v.x;
    y -= v.y;
  }

  public void opMulAssign(float a) {
    x *= a;
    y *= a;
  }

  public void opDivAssign(float a) {
    x /= a;
    y /= a;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-d&#34;&gt;  public void opOpAssign(string op)(Vector v) if (op == &amp;quot;+&amp;quot; || op == &amp;quot;-&amp;quot;) {
    mixin(&amp;quot;x&amp;quot; ~ op ~ &amp;quot;=v.x;&amp;quot;);
    mixin(&amp;quot;y&amp;quot; ~ op ~ &amp;quot;=v.y;&amp;quot;);
  }

  public void opOpAssign(string op)(float a) if (op == &amp;quot;*&amp;quot; || op == &amp;quot;/&amp;quot;) {
    mixin(&amp;quot;x&amp;quot; ~ op ~ &amp;quot;=a;&amp;quot;);
    mixin(&amp;quot;y&amp;quot; ~ op ~ &amp;quot;=a;&amp;quot;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also shows the use of &lt;code&gt;mixin&lt;/code&gt; to generate compile time code.&lt;/p&gt;

&lt;h2 id=&#34;linking-existing-libraries:95834070c7040d18a199c0907f30b458&#34;&gt;Linking existing libraries&lt;/h2&gt;

&lt;p&gt;The game also came with import libraries for SDL, SDL_mixer, OpenGL and GLU and a static library for BulletML, a custom library used by the original developer to load bullet patterns from XML. Those came as .lib files but they couldn&amp;rsquo;t be read by the Windows SDK tools I tried, &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;dumpbin&lt;/code&gt; couldn&amp;rsquo;t read them. However, by luck those files are still supported by &lt;code&gt;dmd&lt;/code&gt; and it managed to link with them.&lt;/p&gt;

&lt;p&gt;The changes required are mostly related to how the extern code was defined. For now, because I was only trying to produce a Windows version, I replaced uses of &lt;code&gt;version(Win32)&lt;/code&gt; (which is now &lt;code&gt;version(Windows)&lt;/code&gt;) with just &lt;code&gt;extern(Windows)&lt;/code&gt; unconditionally.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;--- a/import/opengl.d
+++ b/import/opengl.d
@@ -1,10 +1,4 @@
-version (Win32) {
-	private import std.c.windows.windows;
-	extern(Windows):
-}
-version (linux) {
-	extern(C):
-}
+extern(Windows):
 
 alias uint GLenum;
 alias ubyte GLboolean;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The BulletML binding used &lt;code&gt;extern(C)&lt;/code&gt; and that worked the same so no changes were done.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up:95834070c7040d18a199c0907f30b458&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;With all of this, we&amp;rsquo;ve managed to compile a new Windows executable! What amazed me is how little language changes were necessary. The biggest change was related to Phobos and deprecated library features.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setup Hugo with Travis CI and GitHub Pages</title>
      <link>http://speps.fr/articles/hugo-setup/</link>
      <pubDate>Sun, 24 Jan 2016 11:26:57 +0000</pubDate>
      
      <guid>http://speps.fr/articles/hugo-setup/</guid>
      <description>

&lt;p&gt;This article aims to introduce and show how to generate your &lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt; site on &lt;a href=&#34;http://travis-ci.org&#34;&gt;Travis CI&lt;/a&gt; and then deploy it automatically to &lt;a href=&#34;https://pages.github.com&#34;&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;have-your-hugo-website-ready:64a00e54bc112d22b252689389accbce&#34;&gt;Have your Hugo website ready&lt;/h2&gt;

&lt;p&gt;The first step is to have your Hugo website working locally at least. It should build without errors. The default output folder is &lt;code&gt;public&lt;/code&gt;. NOTE: if you changed that using &lt;code&gt;publishdir&lt;/code&gt; in your config file please change it in the following steps.&lt;/p&gt;

&lt;p&gt;For more information, please refer to &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;Hugo&amp;rsquo;s documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;github-pages-setup:64a00e54bc112d22b252689389accbce&#34;&gt;GitHub Pages setup&lt;/h2&gt;

&lt;p&gt;For GitHub Pages, there are a few options available. You can have User/Organization Pages or Project Pages. The steps presented here should work for both but the different branch names might differ depending on how you want to organize your repository.&lt;/p&gt;

&lt;p&gt;Usually you have a branch with the website sources and another one with the website generated files. In my case, I have a &lt;code&gt;sources&lt;/code&gt; branch and a &lt;code&gt;master&lt;/code&gt; branch because I&amp;rsquo;m using User Pages (same applies to Organization Pages). For Project Pages, you&amp;rsquo;d probably have the sources in the &lt;code&gt;master&lt;/code&gt; branch (in a sub-folder for example) and then the generated files in the &lt;code&gt;gh-pages&lt;/code&gt; branch (as required by GitHub).&lt;/p&gt;

&lt;p&gt;The important thing is to have your sources in the right branch in the first place. For User/Organization pages, it should be any branch other than &lt;code&gt;master&lt;/code&gt;. For Project Pages, it should be any branch other than &lt;code&gt;gh-pages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are plenty of tutorials on how to create a new branch in Git and submit it to your GitHub account. For more information, please refer to &lt;a href=&#34;https://help.github.com/articles/user-organization-and-project-pages/&#34;&gt;User, Organization, and Project Pages&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;travis-ci-setup:64a00e54bc112d22b252689389accbce&#34;&gt;Travis CI setup&lt;/h2&gt;

&lt;p&gt;On Travis CI, you can build and deploy your website automatically.&lt;/p&gt;

&lt;h3 id=&#34;obtain-the-deploy-sh-script:64a00e54bc112d22b252689389accbce&#34;&gt;Obtain the deploy.sh script&lt;/h3&gt;

&lt;p&gt;You need this script in your root folder :&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/X1011/git-directory-deploy/blob/master/deploy.sh&#34;&gt;https://github.com/X1011/git-directory-deploy/blob/master/deploy.sh&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generate-an-access-token-for-github:64a00e54bc112d22b252689389accbce&#34;&gt;Generate an access token for GitHub&lt;/h3&gt;

&lt;p&gt;You need to generate a new &amp;ldquo;Personal Access Token&amp;rdquo; from this GitHub page : &lt;a href=&#34;https://github.com/settings/tokens&#34;&gt;https://github.com/settings/tokens&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Click on &amp;ldquo;Generate new token&amp;rdquo; and follow the instructions. You need to select the &lt;code&gt;public_repo&lt;/code&gt; or &lt;code&gt;repo&lt;/code&gt; scopes. Once the token is generated, you need to copy it.&lt;/p&gt;

&lt;p&gt;Then you need to encrypt it so you can use on Travis CI, &lt;a href=&#34;https://docs.travis-ci.com/user/encryption-keys/&#34;&gt;follow those instructions&lt;/a&gt; and then run this command :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;travis encrypt GIT_DEPLOY_REPO=https://GENERATED_TOKEN@github.com/username/reponame.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Replace &lt;code&gt;GENERATED_TOKEN&lt;/code&gt; with the generated token earlier and &lt;code&gt;username&lt;/code&gt; by your GitHub username and &lt;code&gt;reponame&lt;/code&gt; by the repository name.&lt;/p&gt;

&lt;h3 id=&#34;setup-travis-yml:64a00e54bc112d22b252689389accbce&#34;&gt;Setup .travis.yml&lt;/h3&gt;

&lt;p&gt;In your &lt;code&gt;sources&lt;/code&gt; branch, you have to create a .travis.yml file which will be picked up by Travis CI and be used to configure your build process.&lt;/p&gt;

&lt;p&gt;The contents of .travis.yml should be as follows, &lt;strong&gt;note instructions inlined&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;env:
  global:
    - secure: &amp;quot;...&amp;quot; # replace by the output from travis encrypt done earlier
    - GIT_DEPLOY_DIR=public # this is the default output dir of Hugo
    - GIT_DEPLOY_BRANCH=master # this is the target branch, replace by gh-pages for Project Pages
    - GIT_DEPLOY_USERNAME=&amp;quot;Travis CI&amp;quot; # dummy name
    - GIT_DEPLOY_EMAIL=user@example.com # replace by your email
branches:
  only:
    - sources # replace by master for Project Pages

install:
  - rm -rf public || exit 0 # cleanup previous run
script:
  - binaries/hugo # generate!
after_success:
  - cp .travis.yml public # all branches need this file
  - bash deploy.sh # run the deploy script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE the &lt;a href=&#34;https://github.com/speps/speps.github.io/blob/sources/.travis.yml&#34;&gt;latest version of &lt;code&gt;.travis.yml&lt;/code&gt; will always be at my &lt;code&gt;sources&lt;/code&gt; branch&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;cross-compiling-hugo:64a00e54bc112d22b252689389accbce&#34;&gt;Cross compiling Hugo&lt;/h3&gt;

&lt;p&gt;You could setup your Travis CI to install a Go version, but it will be faster to cross compile the &lt;code&gt;hugo&lt;/code&gt; binary yourself and then deploy it in your &lt;code&gt;sources&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;Run from your root folder those following commands, line by line :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir binaries
cd binaries
env GOPATH=&amp;quot;`pwd`&amp;quot; go get -v github.com/spf13/hugo
env GOPATH=&amp;quot;`pwd`&amp;quot; GOOS=linux GOARCH=amd64 go build -v github.com/spf13/hugo
git add hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will add the &lt;code&gt;hugo&lt;/code&gt; binary compiled for a Travis VM to Git&amp;rsquo;s index. Don&amp;rsquo;t forget to commit it.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up:64a00e54bc112d22b252689389accbce&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;By the end of these steps, you should now have something like this in your root folder :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[root folder]

&lt;ul&gt;
&lt;li&gt;[archetypes]&lt;/li&gt;
&lt;li&gt;[binaries]&lt;/li&gt;
&lt;li&gt;hugo&lt;/li&gt;
&lt;li&gt;[content]&lt;/li&gt;
&lt;li&gt;[data]&lt;/li&gt;
&lt;li&gt;[layouts]&lt;/li&gt;
&lt;li&gt;[static]&lt;/li&gt;
&lt;li&gt;[themes]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.travis.yml&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;config.toml&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deploy.sh&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of those are Hugo&amp;rsquo;s default folders when you create a new site. The important files are &lt;code&gt;.travis.yml&lt;/code&gt; and &lt;code&gt;deploy.sh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once you push everything to GitHub, don&amp;rsquo;t forget to activate your project on Travis CI so it will start builds.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debugging a DirectX memory leak</title>
      <link>http://speps.fr/articles/directx-refcount/</link>
      <pubDate>Sat, 10 Aug 2013 21:31:30 +0000</pubDate>
      
      <guid>http://speps.fr/articles/directx-refcount/</guid>
      <description>&lt;p&gt;A short tale (with pictures and code) of a recent debugging session.&lt;/p&gt;

&lt;p&gt;DirectX uses reference counting to handle the destruction of its resources. When creating a resource, the handle returned by DirectX already has a reference counter of 1. When this resource is not needed anymore, you call Release, each call decrements the reference counter by 1. However, the memory allocated by DirectX for this resource will only be released when the reference counter reaches 0.&lt;/p&gt;

&lt;p&gt;Knowing this, it becomes easy to create your own objects to manage DirectX resources like a VertexBuffer.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/speps/82c86de7540e965b7ef3.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is quite simple in most cases, but you&amp;rsquo;ll have to read through the documentation to know which functions add or hold a reference or not.&lt;/p&gt;

&lt;p&gt;For example looking at ID3D11DeviceContext::IASetVertexBuffers, it says &amp;ldquo;The method will hold a reference to the interfaces passed in&amp;rdquo;. That means while the vertex buffer is bound onto the device, the reference counter for this vertex buffer will be at least one. In other words, this method will call AddRef when a new vertex buffer is bound and Release on the previous one (if there was one). You usually don&amp;rsquo;t have to worry about methods like this one because they behave as expected, a quick MSDN search can find them all.&lt;/p&gt;

&lt;p&gt;Now looking at ID3D11DeviceContext::IAGetVertexBuffers you will notice the documentation says &amp;ldquo;Any returned interfaces will have their reference count incremented by one&amp;rdquo;. This is a clue ! Again, a search can help you find these ones. However, these methods, because they query the current state of the device, should not be used too often. The calls to set the vertex buffers should be cached locally with your own device context wrapper so you don&amp;rsquo;t have to ask the driver what the current state is. These &amp;ldquo;Get&amp;rdquo; methods are expensive, and it&amp;rsquo;s easy to mess up with the reference counting.&lt;/p&gt;

&lt;p&gt;Now onto the memory leak problem. Sometimes you have some complex rendering code, and don&amp;rsquo;t know where the references to your resources are being held. It helps to print the return value of AddRef and Release (which is the reference counter) but it would be great to know when the reference counter is incremented or decremented outside of your own code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://speps.fr/media/articles/directx1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The first intuition that came to me is to check the memory around the pointer to the vertex buffer and check what changes around the calls to AddRef/Release. This somehow works but is not robust enough, you can get an offset and dereference the memory but depending on some parameters (that I didn&amp;rsquo;t have the time to figure out) it wasn&amp;rsquo;t the same offset every time and for every vertex buffer.&lt;/p&gt;

&lt;p&gt;The best solution is to check what the assembler code does. Looking at the assembler code and the different calls and jumps you can figure out how to get to the right value.&lt;/p&gt;

&lt;p&gt;After breaking into dummy calls to AddRef/Release, right click on the code and select &amp;ldquo;Go To Disassembly&amp;rdquo; (that&amp;rsquo;s in Visual Studio 2010).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://speps.fr/media/articles/directx2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, you need to do step-by-step of each instruction and check the registers. Here is a rundown of the flattened sequence to the final increment of the reference counter. Activating the register window in the Debug&amp;gt;Windows&amp;gt;Registers menu is very helpful. This is disassembly from a x64 version of the code above as it&amp;rsquo;s easier to follow than x86 in my opinion, but the same steps can be applied.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/speps/3e2ba0d88c3894f9bdee.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;At the end of the first &amp;ldquo;call&amp;rdquo; instruction, rcx contains the this pointer. Then the address in &amp;ldquo;rcx + 0x18&amp;rdquo; is dereferenced and put back into rcx. After the &amp;ldquo;jmp&amp;rdquo; instruction, the xadd instruction adds one to the value at address &amp;ldquo;rcx + 8&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s construct a helper macro to get the current reference count of our vertex buffer. This is mostly for debug purposes as the reference counter is very likely atomic (as noted by the &amp;ldquo;lock xadd&amp;rdquo; instruction which is an atomic exchange and add).&lt;/p&gt;

&lt;p&gt;In C and C++, to be able to add bytes to an existing pointer, you need it to be char&lt;em&gt;. Doing pointer arithmetic with void&lt;/em&gt; is a compile error and adding to other types shifts by the size of the type so you have to be careful. For example pInt+1 if pInt is int* will actually point to pInt+8 if sizeof(int) is 8.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/speps/cd3139aab7ad2f713963.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Modifying the previous code to debug the reference counter gives us the right value.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/speps/50cfb074e0c9e524e17b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Printing the address of the reference counter is very useful for setting a data breakpoint.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://speps.fr/media/articles/directx3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next time the reference counter is changed internally by a DirectX call, you&amp;rsquo;ll see that the breakpoint is hit.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://speps.fr/media/articles/directx4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And you can see the callstack, in Tutorial02 from the DirectX samples, I hit the breakpoint during CleanupDevice which calls Release.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://speps.fr/media/articles/directx5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I hope this will help in debugging a few memory leaks which may result from some misplaced or missing AddRef/Release calls.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>